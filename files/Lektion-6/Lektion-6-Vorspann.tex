\cleardoublepage
\chapter*{Einleitung zur Lektion}
\addcontentsline{toc}{chapter}{Einleitung zur Lektion}
\markboth{Einleitung zur Lektion}{Einleitung zur Lektion}

Beim Softwareengineering geht es natürlich im Endeffekt um Software, also um die Erstellung von Programmcode. In den vorhergehenden Lektionen und Kapiteln standen Modelle im Vordergrund, die auf unterschiedlichen Abstraktions\-ebenen beschreiben, was diese Software leisten soll und wie sie strukturiert ist. Bei der Realwelt\-modellierung haben wir uns auf die betrachtete Domäne mit ihren Konzepten und auf die Anforderungen verschiedenartiger Nutzergruppen konzentriert und diese wesentlichen Aspekte festgehalten. Darüber hinaus ging es um Architektur\-entscheidungen für die Software sowie um eine modellbasierte Sicht des Softwaresystems, also um einen groben Entwurf der Software. Dieser abstrahiert gewissermaßen sowohl von der Realwelt mit ihren Anforderungen und gewünschten Abläufen als auch von der tatsächlich zu implementierenden Software, er modelliert also zugleich zwei ganz unterschiedliche Welten. Nachdem wir uns bisher (bezogen auf die Abstraktionsebene) hochgearbeitet haben, geht es nun in die andere Richtung wieder herunter, fast bis zum implementierten Code selbst. Aber nur fast, denn die Programmierung ist nicht mehr Teil des Softwareengineerings, und sie wird an der FernUniversität in anderen Modulen behandelt. Gerade im Bereich der Objekt\-orientierung gibt es aber natürlich Gemeinsamkeiten und Schnittstellen zwischen objektorientierter Modellierung und objektorientierter Programmierung.

Unser Flug von der Realwelt und ihren Anforderungen zu den höheren Sphären der Modellierung bereitet sich also auf die Landung vor. Dazu müssen wir allerdings wissen, wo wir eigentlich hinwollen. Konkret müssen Entscheidungen getroffen werden, die das Zielsystem und die zu verwendende Sprache betreffen. In diesem Text gehen wir davon aus, dass der Code schließlich in Java vorliegen soll und berücksichtigen deshalb Möglichkeiten und Einschränkungen dieser objektorientierten Sprache -- bei anderen Zielsprachen würden Entscheidungen analog, aber manchmal eben etwas anders gefällt werden. 

In Kapitel "`Feinentwurf"' dieser Lektion (Kapitel~\ref{sec:Kap-9}) geht es um Prinzipien und Tricks bei der Programmerstellung, mit den Zielen Qualität und Korrektheit, Wartbarkeit und insbesondere Komplexitätsbeherrschung. Zu dem letzten Begriff hier einige kurze Anmerkungen: Wir müssen stets vermeiden, dass Systeme unnötig komplex erscheinen. Dazu diente die gesamte bisherige Modellierung, denn oft liegt der Grund unnötiger Komplexität im fehlenden Verständnis der Domäne oder der Anforderungen. Trotzdem verbleibt eine hohe Komplexität; heutige Softwaresysteme sind die komplexesten Artefakte, die die Menschheit hervorgebracht hat. Hier geht es da\-rum, diese Komplexität zu beherrschen, indem man komplexe Systeme vernünftig strukturiert und ihre Module erkennt und verwendet. Und indem man die durch die UML angebotenen Abstraktionsmechanismen so anwendet, dass auch sich weiter entwickelnde Systeme (und ihre Modelle) verstanden werden können. Hinzu kommen Transformationsregeln, die im Landeanflug eingesetzt werden, um die Modelle kompatibel zu den in der Zielsprache (Java) realisierbaren Konstrukten zu machen.

Wir haben das Thema Entwurfsmuster aus dem Bereich herausgelöst und ihm ein eigenes Kapitel gewidmet (Kapitel~\ref{sec:Kap-10}). Dabei geht es ebenfalls um die Verwendung von Strukturen beim Programmieren, aber hier aus der Perspektive bewährter \mbox{Lösungen}. Mit diesen Mustern wird versucht, den Erfahrungsschatz in der Programm\-entwicklung aus der Vergangenheit über die beteiligten Personen hinaus verfügbar zu machen -- nicht jeder muss das Rad immer wieder neu erfinden. Aber die Verwendung von Mustern hat auch noch einen weiteren positiven Effekt: Bei der Programm\-entwicklung in Teams oder bei der späteren Weiterentwicklung eines Programms ist es sehr hilfreich, wenn man bewährte und bekannte Muster wiederfindet, die das grundsätzliche Verständnis für den Aufbau eines Softwaresystems erleichtern. 

\sttpUniversalkasten{Lernziele zu Lektion 6}{Nach dieser Lektion
	\begin{itemize}
		\item können Sie erklären, was Sichtbarkeiten sind und inwiefern sie das \mbox{Geheimnisprinzip} unterstützen. Sie wissen, was man unter einer Signatur versteht und in welchem Zusammenhang sie zu Interfaces steht,
		\item kennen Sie die Begriffe Kopplung und Kohäsion, ihren Zusammenhang sowie ihren Einfluss auf die Modulgestaltung. Sie können erklären, welcher Idealzustand zwischen Kopplung und Kohäsion angestrebt wird und mit welchen Maßnahmen man sich diesem nähern kann, 
		\item wissen Sie, was das Substituierbarkeitsprinzip aussagt und was man unter Konformität versteht. Sie können die Zusammenhänge zwischen \mbox{Substituierbarkeit}, Konformität, Generalisierung und Vererbung erläutern,	
		\item können Sie unter Einsatz der im Text vorgestellten Transformationen UML-Klassenbeziehungen in UML-Elemente umwandeln, die sich in Programmcode übertragen lassen, 
		\item können Sie erklären, was Entwurfsmuster sind, wozu diese gut sind und in welche Kategorien man sie einteilt. Sie wissen, worin sich Entwurfsmuster und Architekturmuster unterscheiden. 
	\end{itemize}
}
