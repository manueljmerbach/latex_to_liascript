\section{Modellgetriebene Softwareentwicklung}
%\label{sec:Kap-4.1}

Die sogenannte „Modellgetriebene Softwareentwicklung“ – engl. model-driven (software) development (MDSD, MDD) oder model-driven (software) engineering (MDSE, MDE) – umfasst als Sammelbegriff alle Methoden, die Programmcode – allerdings in der Regel nicht den kompletten! –  für ein zu erstellendes Softwareprodukt automatisiert aus Modellen erzeugen. Zusätzlich zum Programmcode können auch andere Artefakte wie Konfigurationsdateien, Datenbankskripte, Softwaretests oder Dokumentationen weitere Ergebnisse von MDSD-Prozessen sein, die Erstellung von Programmcode gehört aber immer dazu. Manche Methoden der modellgetriebenen Entwicklung setzen erst bei späteren Prozessen des Softwareengineering ein, verwenden zum Beispiel (nur) ein schon sehr implementierungsnahes Modell, das dann in Programmcode übersetzt wird. Andere Methoden arbeiten bereits mit dem Domänenmodell und der Menge der Anforderungen als Ausgangsbasis für die Programmcodeerzeugung.

Modellgetriebene Softwareentwicklung ist ein Thema, das seit Anfang der 2000er Jahre verstärkt in den Fokus des Softwareengineering gelangte. Dazu hat auch beigetragen, dass die Object Management Group (OMG) – die auch die UML herausgibt – zu dieser Zeit mit der sogenannten Model Driven Architecture 
\marginline{MDA}
(MDA, \url{https://www.omg.org/mda/}) einen spezifischen Ansatz eines MDSD als Standard veröffentlichte.

Für modellgetriebene Softwareentwicklung benötigt man ein Ausgangsmodell in einer geeigneten Modellierungssprache und eine Menge sogenannter \textit{Transformationsregeln}. 
\marginline{Transformationen}
Diese definieren, wie aus einer gegebenen Struktur (in diesem Fall zu Beginn das Ausgangsmodell) eine andere Struktur (ein verfeinertes Modell oder der Programmcode) abgeleitet wird. MDSD beinhaltet Transformationen von Modell-Strukturen in Programmcode-Strukturen – diesen Vorgang nennt man Generierung und das Werkzeug, das den Vorgang durchführt, Generator –, aber auch Transformationen von Modell-Strukturen in andere Modell-Strukturen. Die meisten Methoden der modellgetriebenen Softwareentwicklung sehen nicht die direkte Transformation eines Ausgangsmodells in Programmcode vor, sondern stattdessen eine Folge von Transformationen, bei denen die jeweiligen Ausgangsmodelle mit Informationen angereichert werden. Dadurch werden schrittweise weniger abstrakte Modelle und als letzter Schritt der Programmcode erzeugt.

Ziel von MDSD-Ansätzen ist die Erhöhung der Effizienz der Softwareerstellung durch Reduktion des Aufwands für Implementierungstätigkeiten durch eine möglichst weitgehende Automatisierung der Programmcodeerstellung. Gleichzeitig verspricht man sich einen höheren Grad an Konsistenz zwischen den Modellen, die im Rahmen von An\-for\-de\-rungs\-er\-mitt\-lungs- oder Entwurfsprozessen entstanden sind, und dem Programmcode des Softwareprodukts: Bei einem \textbf{nicht}-modellgetriebenen Umgang mit Modellen innerhalb eines Softwareentwicklungsprozesses – man nennt dies in Abgrenzung auch modell\textbf{basiert} – entsteht in der Praxis oft die Situation, dass ab einem gewissen Zeitpunkt im Projektverlauf Änderungen der Software nur noch auf der Ebene des Programmcodes vorgenommen werden und die eigentlich vorgeschalteten Modelle nicht ebenfalls angepasst werden. Zudem bergen manuelle Transformationen zwischen Modell und Programmcode ein höheres Risiko für Übertragungsfehler oder für die Erweiterung des Programmcodes um implizite (Fehl)Informationen und Annahmen des Übertragenden, die im Modell aber gar nicht vorkommen. Die modellgetriebene Softwareentwicklung versucht die Entstehung von Fehlern und Inkonsistenzen zu vermeiden, indem notwendige Änderungen nur auf Ebene der Modelle vorgenommen werden und anschließend auf dieser Basis der Programmcode neu generiert wird.

Für den Einsatz von modellgetriebener Softwareentwicklung ergeben sich zwei große Herausforderungen. Erstens ist zur Erstellung des Ausgangsmodells eine geeignete Modellierungssprache von Nöten und zweitens existiert ein Nebeneinander von generiertem und manuell erstelltem Programmcode, da die vollständige Generierung des Programmcodes in den meisten Fällen nicht funktioniert. 

Für das Ziel der automatischen Programmcodeerstellung wird als Ausgangsmodell ein formales Modell benötigt, das durch einen Generator ausgewertet werden kann. \marginline{Formales Modell}
\textit{Formales Modell} beinhaltet erstens, dass die Bedeutung der verwendeten Modellierungselemente eindeutig ist. Es darf keinerlei Interpretationsspielraum und keine impliziten Annahmen geben. Zweitens darf nur eine bestimmte Menge an Elementen (nämlich genau die, die der Generator versteht) verwendet werden. Die zur Verfügung stehenden Elemente der Modellierungssprache müssen aber gleichzeitig ausreichend sein, um alle Konzepte – sowohl Domänenkonzepte als auch technische Konzepte –, die man zur Modellierung benötigt, abbilden zu können. Grafische Modellierungssprachen wie die UML erfüllen die Notwendigkeit der Eindeutigkeit häufig nicht. Sie werden deshalb im Rahmen der modellgetriebenen Softwareentwicklung um formale textuelle Beschreibungen ergänzt, im Falle der UML zum Beispiel mithilfe der Object Constraint Language (OCL, s. Lektion~5),
%\sttpkapitelverweis{OCL}{Kap.~\ref{sec:Kap-x.y}}
die seit der UML Version 2 in den Standard integriert ist. Seit der Version 2.2 der UML können zudem auf einer Meta-Modellebene sogenannte UML-Profile erstellt werden. Auf diese Weise können vorhandene UML-Elemente (und damit deren Semantik) für die Bedürfnisse des eigenen Projekts angepasst werden, und damit zum Beispiel UML-Elemente, denen die notwendige Eindeutigkeit für Zwecke der modellgetriebenen Softwareentwicklung fehlt, in ihrer Bedeutung entsprechend spezialisiert werden. 

Die 
\marginline{domänenspezifische (Modellierungs) sprache}
Anpassung der UML durch ein UML-Profil ist eine Möglichkeit, eine sogenannte \textit{domänenspezifische Sprache} (engl. domain-specific language, DSL) als Modellierungssprache für das Ausgangsmodell zu erstellen. Domänenspezifische Sprachen – die kein Spezifikum der Modellierung sind, sondern in der Informatik in vielen Bereichen eingesetzt werden – sind formale Sprachen, die im Gegensatz zu universell einsetzbaren Sprachen (im Bereich der Modellierungssprachen zum Beispiel UML), komplett auf die Domäne zugeschnitten sind. Damit können sie zum einen von Domänenexperten verstanden werden, sind zum anderen (weil sie formale Sprachen sind) aber auch maschinell auswertbar und damit im Rahmen der modellgetriebenen Softwareentwicklung einsetzbar. Die Entwicklung einer domänenspezifischen Modellierungssprache im Vorfeld der Erstellung des Ausgangsmodells ist allerdings mit Aufwand verbunden, umso mehr, je weniger man in seiner Domäne auf vorhandene Sprachen und entsprechende Generatoren zurückgreifen kann. Der Effizienzvorteil durch den geringeren Aufwand bei den Implementierungstätigkeiten im Rahmen von MDSD-Ansätzen kann dadurch geschmälert oder sogar aufgehoben werden. 

Die zweite Problematik bei MDSD-Ansätzen ist, dass es in der Praxis meist nicht gelungen ist, eine automatische Generierung des \textbf{kompletten} Programmcodes des zu erstellenden Softwareprodukts zu erreichen. So setzt sich der Programmcode schließlich aus generierten und manuell erstellten Teilen zusammen. In jedem konkreten Softwareentwicklungsprozess muss es daher spezifische Arbeitsprozesse und Verfahren geben (\zb verschiedene Dateien, Namensräume), die sicherstellen, dass bei erneuten Transformationen von Ausgangsmodell zu Programmcode der bisher erstellte manuelle Teil des Programmcodes nicht verloren geht und korrekt integriert wird.

Ansätze der modellgetriebenen Softwareentwicklung 
\marginline{MDSD und agile Ansätze}
sind grundsätzlich auch an agile Prinzipien anschlussfähig, da Modelle aus dem Blickwinkel von MDSD immer ausführbare Modelle (engl. executable models) sind. Damit bilden sie nicht zusätzliche Artefakte zum Programmcode, die konsistent gehalten werden müssen. Sie haben stattdessen den Stellenwert von Programmcode, auch wenn sie auf einer anderen Abstraktionsebene operieren. Die agile Modellierung im Sinne von \cite{amb02}, in der Modelle „gerade gut genug“, aber nicht mehr sein müssen (s. Kap.~\ref{sec:Kap-3.2.3}), hätte allerdings bis zur Ebene des für MDSD benötigten formalen Ausgangsmodells einen deutlich größeren Spalt zu überbrücken als die klassische Modellierung. 

% TODO Kommentar in Latex-Datei: „evtl. Verweis auf KE6“
Insgesamt steht und fällt die Praktikabilität von MDSD-Ansätzen mit der Verfügbarkeit von domänenspezifischen Sprachen, Generatoren – bzw. der eigenen Möglichkeit, Sprachen und Generatoren zu erstellen – und den entsprechenden Tools, die die Tätigkeiten der modellgetriebenen Softwareentwicklung hinreichend komfortabel unterstützen können. In einer gewissen Konkurrenzsituation steht die modellgetriebene Softwareentwicklung heutzutage zudem mit der Vielzahl an verfügbaren Frameworks, Softwarekomponenten, Klassenbibliotheken etc., bei deren Verwendung man den Programmcode seines Softwareprodukts ebenfalls nicht mehr komplett selbst erstellen muss.

Eine umfassende Darstellung 
\marginline{Literatur}
von modellgetriebener Softwareentwicklung inklusive detaillierten Ausführungen zur Erstellung von DSL und Generatoren findet sich bei \cite{sta07}. Eine Übersicht zu MDSD im Allgemeinen und MDA im Besonderen bietet zudem \cite{tro07}. Explizit mit dem von der OMG standardisierten MDA-Ansatz beschäftigt sich zusammenfassend \cite[184-187]{som18} und sehr ausführlich mit Fallbeispielen \cite{pet06}. In \cite[101 \psqq]{amb04} beschreibt der Autor, wie auf Basis von agiler Modellierung eine agile modellgetriebene Softwareentwicklung aussehen könnte. Hier bleibt allerdings unklar, in welchem Ausmaß eine automatisierte Programmcodeerzeugung möglich wäre, es sich also wirklich um einen modell\textbf{getriebenen} Ansatz handelt. Die beiden zusammengehörigen Bücher \cite{rum11} und \cite{rum12} stellen einen MDSD-Ansatz vor, bei dem eine domänenspezifische Sprache mithilfe der UML-Profile sowie der Einbindung von OCL und spezifischen Java-Codeteilen gebildet wurde. Vorgestellt wird dort außerdem, wie sich dieser Ansatz mit agilen Prinzipien verbinden lässt.