\subsection{Was ist Softwareengineering?}
\label{sec:Kap-1.2.1}

Softwareengineering wurde erstmalig bedeutsam, als Software breitentauglicher (Einsatz auch außerhalb von Forschungseinrichtungen) werden sollte und gleichzeitig die Einsatzfelder von Software zu kritisch waren (\zb Verteidigungssysteme, medizinische Geräte), als dass man „ungeplant“ hätte entwickeln können. Aus den bisherigen Darstellungen sollte deutlich geworden sein, dass es im Laufe der letzten Jahrzehnte sich verändernde, ergänzende, aber teilweise auch konkurrierende Vorstellungen gab, welche Aspekte Softwareengineering beinhalten und in welche Richtung es sich weiterentwickeln soll. Wenn man heute in Lehrbüchern nach Definitionen zum Softwareengineering sucht, findet man -- trotz Standardisierungsbemühungen wie den Arbeiten an SWEBOK -- immer noch viele verschiedene Vorschläge. Zum einen unterscheiden sie sich darin, welche Prozesse aus dem Bereich der Erstellung von Software dem Softwareengineering zugerechnet werden und welche nicht: Gehören beispielsweise die Kostenkalkulation des Softwareprojekts, die Zusammenstellung des Entwicklerteams oder die Wahl des Vorgehensmodells schon in den Bereich Softwareengineering oder beginnt Softwareengineering erst \textbf{danach}? Wann endet Softwareengineering: Inwiefern gehören Wartung, Weiterentwicklung, aber auch Vertrieb der Software dazu? Zum anderen gehen die Meinungen, inwieweit Softwareengineering eine (echte) ingenieurwissenschaftliche Disziplin ist, auch heute noch auseinander (dasselbe gilt im Übrigen auch für die gesamte Informatik). Die Gründe für die unterschiedlichen Vorstellungen über das Gebiet Softwareengineering sind die gleichen wie vor fünfzig Jahren: Menschen mit unterschiedlichen (beruflichen) Hintergründen oder unterschiedlichen aktuellen Arbeitsgebieten definieren Softwareengineering und vor allem auch das Aufgabengebiet von Softwareingenieuren und -ingenieurinnen unterschiedlich.

Nichtsdestotrotz
\marginline{Prinzipien des Ingenieur\-wesens für die Entwicklung von Software nutzen} 
besteht heute Einigkeit darüber, dass Softwareengineering sich dadurch auszeichnet, dass Prinzipien des Ingenieurwesens auf die Entwicklung von Software angewendet werden. Dazu gehören die systematische Entwicklung und Verwendung von Methoden, Standards und Werkzeugen und die Entwicklung von Maßsystemen zur Messung und Qualitätsbeurteilung von Softwareeigenschaften genauso wie die intensive Nutzung von Erfahrungswerten.

Des Weiteren sind folgende Punkte Konsens: 
\begin{itemize}
	\item Softwareengineering ist mehr als nur Programmierung, beinhaltet also noch weitere Prozesse.
	\item Softwareengineering beschäftigt sich mit der \textbf{systematischen} Entwicklung von \textbf{komplexer} Software. Es geht also zum einen darum, geplant zu entwickeln, statt „irgendwie zu programmieren“. Und zum anderen liegt der Fokus auf den größeren, komplexeren Softwaresystemen und nicht auf dem kleinen, einfachen Programm zur automatischen Bewässerung der eigenen Zimmerpflanzen.
	\item Softwareengineering beruht neben theoretischen (mathematischen) Grund\-lagen auch auf heuristischen Techniken und Methoden (Best Practices).
\end{itemize}

\pagebreak %%% für Druck

Der schon erwähnte SEVOCAB-Standard definiert Softwareengineering dementsprechend als: 

\sttpzitat{„systematic
\marginline{Definition\\Software\-engineering} 
application of scientific and technological knowledge, methods, and experience to the design, implementation, testing, and documentation of software.”}{Eintrag „software engineering“ bei \href{http://www.computer.org/sevocab}{www.computer.org/sevocab}}

\vspace{\baselineskip} %%% für Druck

Die SEVOCAB Softwareengineering-Definition stellt die theoretisch fundierten Erkenntnisse und die Erkenntnisse aus praktischen Erfahrungen gleichwertig neben\-einander. Wie Sie im Laufe des Textes noch lesen werden, dominieren aber in manchen Prozessen des Softwareengineering – vor allem in der Anforderungsermittlung und im Entwurf – heute die Best Practice Techniken. Eine theoriegeleitete Beschäftigung mit Softwareengineering existiert nichtsdestotrotz auch heute noch, und dies hat auch eine starke Berechtigung. Einerseits werden hier Grundlagen entwickelt, die in der Zukunft die Softwareentwicklung revolutionieren könnten. Zum Anderen unterscheiden sich Softwaresysteme unter anderem darin, welche Konsequenzen Fehler haben. Stark sicherheitskritische Anwendungen, zum Beispiel in der Raumfahrt oder in der Medizintechnik, erfordern ein weit höheres Maß an Vertrauen in die Korrektheit von Software als andere Anwendungen; hier spielen formale Methoden weiterhin eine große Rolle.

\vspace{\baselineskip} %%% für Druck

\phantomsection
\label{text:theoVertreter}

\sttpKastenBreakable{\textbf{formale Methoden vs. Best Practices}

Schon lange vor der Entstehung von agilen Entwicklungsansätzen, die in den 1990er Jahren eine bis heute bestehende Konfliktlinie zwischen Befürwortern und Gegnern agiler Softwareentwicklung eröffneten (s. Kap.~\ref{sec:Kap-2.3}), existierte im Softwareengineering eine ältere Konfliktlinie zwischen zwei wettstreitenden Fraktionen: diejenigen, die an formale Methoden und Korrektheitsbeweise für Software glaubten, und diejenigen, die all diese mathematisch-logisch orientierten Methoden für nicht praktikabel und viel zu aufwändig hielten. Beide Seiten hielten sich gegenseitig mangelhaftes ingenieurmäßiges Denken vor: Die formale Fraktion verwies auf die formalen Grundlagen in den anderen Ingenieurwissenschaften (\zb Statikberechnungen), die andere Seite verwies auf die Orientierung an Best Pratices und die Notwendigkeit, Methoden für aktuell existierende Probleme und aktuelle Softwareentwicklungsprojekte zu erstellen, statt Grundlagen für irgendeine Zukunft zu legen. Formale Spezifikationen zu Projektbeginn bei der Formulierung von Anforderungen können in diesem Zusammenhang als ein Kompromiss betrachtet werden. Die Vision der formalen Fraktion war und ist, dass Software eigentlich gar nicht mehr (von Menschen) entwickelt werden muss, sondern automatisch aus hinreichend präzisen Anforderungen generiert wird und dann per Konstruktion diese Anforderungen erfüllt (natürlich muss dafür auch diese Generierungssoftware fehlerfrei sein). Mit diesem Ziel wurden und werden eigene Sprachen für die Spezifikation und auch neue Programmiersprachen entwickelt. Man könnte diese Forschungsrichtungen ebenfalls Softwareengineering nennen, tatsächlich verteilen sie sich aber über andere Teildisziplinen der Informatik, und werden auch an der FernUniversität in anderen Modulen gelehrt. Deshalb gehen wir auch in diesem Text den sehr formalen Ansätzen nicht intensiver nach. Bemerkenswert bleibt aber, dass die Ursprünge des Softwareengineering durchaus auch auf eher formalen Ansätzen beruhten und beide genannten Fraktionen anfangs beteiligt waren.}

\vspace{\baselineskip} %%% für Druck

Softwareengineering ist ein Fachgebiet, das sich weiterhin im Wandel befindet. Anhand der Herausforderungen neuer Softwarekonzepte oder neuer Arten von Soft\-ware\-syste\-men entstehen neue, erweiterte oder veränderte Programmiersprachen, Notationen, Vorgehensmodelle, Methoden und Techniken in allen Bereichen des Soft\-ware\-lebens\-zyklus - und das meist außerhalb des wissenschaftlichen Bereichs. Jenseits aller Standardisierungsbemühungen und verschiedener Versuche, der Disziplin ein stärkeres wissenschaftliches Fundament zu geben, wird sich Softwareengineering auch weiterhin in erster Linie dadurch definieren, welche Fähigkeiten ein Soft\-ware\-inge\-nieur in der Praxis benötigt und was er in seiner täglichen Arbeit tut. Die universitäre Lehre (und einen Lerntext zum Thema Softwareengineering) stellt dies vor große Herausforderungen. Wenn wir uns zu sehr auf die neuesten oder aktuell beliebtesten Entwurfsmethoden, Frameworks oder Entwicklungswerkzeuge konzentrieren, könnte das, was wir heute als neueste Errungenschaften lehren, morgen schon wieder veraltet sein. Es könnte sich auf der anderen Seite in der Praxis (noch) nicht durchgesetzt haben bzw. sich nie durchsetzen. Um das beliebte Beispiel der Vorgehensmodelle noch einmal zu bemühen: Wir können sowohl Scrum als auch das Wasserfallmodel vorstellen (und werden das auch tun), aber aus Lehrperspektive wichtiger ist die Vermittlung, was ein Vorgehensmodell auszeichnet, warum man es im Softwareengineering einsetzt und welche Vor- und Nachteile unterschiedliche Kategorien von Vorgehensmodellen haben.

Heute gibt es sehr viele unterschiedliche Arten von Softwaresystemen, für die unterschiedliche Softwareengineering-Techniken erforderlich sind. So werden sich das Softwareengineering für eine stand-alone Fotobearbeitungssoftware, für ein eingebettetes System eines Autos und für eine Webanwendung eines Onlineshops in den eingesetzten Programmiersprachen, Vorgehensmodellen und Entwurfstechniken stark unterscheiden.
\marginline{die grundlegenden Aspekte des Software\-engineering} 
Die unterliegenden Ideen und Konzepte des Softwareengineering lassen sich aber für alle Softwaresysteme anwenden: Für jede industriell gefertigte Software müssen in irgendeiner Art und Weise Anforderungen spezifiziert werden, die in irgendeiner Notation dokumentiert werden müssen. Jede Software durchläuft irgend\-wann einen oder mehrere Entwurfsprozess(e), muss implementiert, verifiziert oder getestet, an die Kunden ausgeliefert und gewartet werden. Und alle diese Aktivitäten müssen innerhalb gegebener Zeit-, Kosten- und Personalbudgets in hoher Qualität erfolgreich abgeschlossen werden. Dementsprechend beschäftigt sich dieser Text schwerpunktmäßig mit den grundlegenden Aspekten des Softwareengineering, die unabhängig von der Art des zu entwickelnden Softwaresystems eine Bedeutung haben.

\clearpage %%% für Druck