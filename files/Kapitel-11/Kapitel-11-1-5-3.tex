\vspace{1mm} %%% für Druck

\minisec{Pfadüberdeckung} % ist absichtlich nur noch \minisec

Betrachten wir zur Motivation wieder das vorletzte, nicht korrekte Beispiel des ggT-Algo\-rith\-mus (Algorithmus~\ref{algo:zweiter_reparaturversuch}). Wir haben bereits einen Fall gefunden, für den der Algorithmus nicht das korrekte Ergebnis liefert (und sogar gar kein Ergebnis liefert), nämlich bei Eingabe zweier gleicher Werte für $a$ und $b$. In diesem Fall wird die Bedingung $a>b$ für die \textbf{if}-Anweisung zu \emph{falsch} ausgewertet und die anschließende Schleifenabbruchbedingung $a=b$ (nachdem $b$ auf 0 gesetzt wurde) ebenfalls zu \emph{falsch} ausgewertet.

Wir können den Fehler durch Tests nur finden, wenn wir eine entsprechende Kombination von Bedingungsauswertungen und anschließenden Zweig-Ausführungen konstruieren: erst wird der \textbf{else}-Zweig durchlaufen, anschließend die Schleife nicht abgebrochen.

Während die auf Bedingungen folgenden Anweisungen die einzelnen Programmzweige darstellen, sind \emph{Pfade} durch derartige Kombinationen von Zweigen gegeben. In dem genannten Beispiel wird der Fehler durch einen Testlauf gefunden, wenn ein Pfad begangen wird, der mit den Auswertungen $a>b$ ist \emph{falsch}, $a=b$ ist \emph{falsch} beginnt.

\emph{Pfadüberdeckung} 
\marginline{Pfad\-überdeckung}
durch Tests bedeutet, dass jeder mögliche Pfad durch wenigstens einen Testlauf betrachtet wird. Diese Forderung ist grundsätzlich noch realisierbar, wenn es keine Schleifen gibt. Hat ein Programm zum Beispiel fünf voneinander unabhängige aufeinanderfolgende \textbf{if}-Verzweigungen, so gibt es fünf mal hintereinander zwei mögliche Zweige. Die Anzahl der Pfade ist daher $2^5 = 32$. Diese 32 Pfade müssen durch wenigstens 32 Testläufe realisiert werden.

Schwieriger wird es, wenn das betrachtete Programm Schleifen enthält, denn je nach Anzahl der Schleifendurchläufe wächst die Anzahl der Pfade exponentiell, sofern innerhalb der Schleife eine Verzweigung vorkommt. So gibt es in unserem Beispiel (zweiter Reparaturversuch, Algorithmus~\ref{algo:zweiter_reparaturversuch}) bei einem Schleifendurchlauf zwei \mbox{Pfade}, bei zwei Schleifendurchläufen vier Pfade, bei drei Schleifendurchläufen acht Pfade usw. Da aber die Anzahl der Schleifendurchläufe nicht grundsätzlich begrenzt ist oder von der Eingabe abhängt, kann man die Forderung alle Pfade zu besuchen, kaum erfüllen. Unser Beispielprogramm hat sogar eine potentielle Endlosschleife, ohne obere Grenze für die Zahl der Schleifendurchläufe.

Statt tatsächlich alle Pfade zu durchlaufen, gibt es abgeschwächte Forderungen für Pfad\-über\-deckung, die bei Schleifen zum Beispiel nur drei verschiedene Ausführungswiederholungszahlen betrachten (null, eine, zwei Ausführungen bei \textbf{while-}Schleifen / eine, zwei, drei Ausführungen bei \textbf{repeat}-Schleifen). Die meisten Fehlerfälle in der Praxis benötigen nicht mehr Schleifendurchläufe, doch kann man leicht Gegenbeispiele konstruieren, bei denen der Fehlerfall erst bei einer höheren Zahl auftreten kann.

Auch die derart modifizierte Forderung nach Pfadüberdeckung führt allerdings oft zu immensen Testfallmengen. Der Aufwand zur Konstruktion dieser Tests kann ebenfalls sehr hoch sein. So sind aufeinanderfolgende Verzweigungen oft tatsächlich nicht unabhängig. Zum Beispiel mag es sein, dass in keinem Ablauf drei aufeinanderfolgende Verzweigungsbedingungen zu \emph{wahr} ausgewertet werden, die darauffolgende vierte Bedingung aber zu \emph{falsch}. Also kann man auch keinen derartigen Testfall konstruieren. Umgekehrt bedeutet Pfadüberdeckung aber, dass ein derartiger Testfall betrachtet werden muss, wenn er möglich ist.

Im Allgemeinen ist die Anzahl möglicher Pfade zu groß, um die Pfadüberdeckung zu realisieren. Hinzu kommt, dass weder alle möglichen Pfade bekannt sind (und mit Tests auch nicht zuverlässig gefunden werden können), und dass die Konstruktion von geeigneten Eingabedaten für einen gegebenen Pfad ein nichttriviales Problem darstellt.

Pfadüberdeckung ist daher eher eine theoretische Überlegung als eine in der Praxis übliche Forderung. Bei einfacheren Programmen ist Pfadüberdeckung allerdings möglich. Pfadüberdeckung darf nicht verwechselt werden mit einem Test \textit{aller} möglichen Eingabewerte. Wenn wir tatsächlich jede Eingabe testen und der Prüfling für jede Eingabe das korrekte Ergebnis liefert, ist er per Definition korrekt. Der Test aller gültigen Eingabewertkombinationen ist aber bis auf ganz wenige Ausnahmen niemals möglich, denn die Zahl möglicher Eingabewertkombinationen kann grundsätzlich exponentiell mit der Länge der gesamten Eingabe (in Bits) wachsen. Da im Allgemeinen zu einem Pfad aber viele unterschiedliche Eingabewertkombinationen gehören, wird das Testen aller Eingaben für die Pfadüberdeckung nicht gefordert. 