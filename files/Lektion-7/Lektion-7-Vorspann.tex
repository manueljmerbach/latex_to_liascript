\cleardoublepage
\chapter*{Einleitung zur Lektion}
\addcontentsline{toc}{chapter}{Einleitung zur Lektion}
\markboth{Einleitung zur Lektion}{Einleitung zur Lektion}

Herzlichen Glückwunsch, Sie haben es fast geschafft! Vor Ihnen liegt die siebte und letzte Lektion des Moduls. Sie besteht aus nur einem Kapitel, wir hätten den Inhalt aber genauso gut auch in zwei Kapitel aufteilen können. Das übergreifende Thema ist Qualitätssicherung, und es geht sehr grob gesagt um die Prüfung, ob ein Programm das tut, was es soll, oder allgemeiner, ob es die Anforderungen erfüllt. Sie werden erfahren, dass dies kein Thema ist, dem man sich ausschließlich am Ende des Softwareentwicklungsprozesses widmen darf, aber das wissen Sie eigentlich schon seit der ersten Lektion.

Mehr noch als in den anderen Lektionen haben wir die möglichen Inhalte zu Qualitätssicherung stark ausgewählt, um sie Ihnen überhaupt als eine Lektion eines Moduls präsentieren zu können. Sehr grob behandeln wir anwendungsorientierte Aspekte und Werkzeugunterstützung, beides schnelllebige Themen, die Sie im beruflichen
Kontext leicht nachholen werden. Vertieft gehen wir dagegen auf Grundlagen wie genaue Definitionen und mathematisch fundierte Verfahren ein, und erwarten anschließend auch von Ihnen in diesen Bereichen entsprechende Präzision. Aber -- wie so oft -- lernen Sie nicht für die Klausur, sondern für Ihr Berufsleben. Wir sind davon überzeugt, dass unsere Auswahl von Qualitätssicherungsthemen Sie langfristig im beruflichen Kontext mehr unterstützt als eine Anleitung zu aktuellen Verfahren im Qualitätswesen, ganz abgesehen von der notwendigen Vorbereitung für weiter\-gehende Ansätze in anderen Modulen oder im Masterstudium.

Wir teilen diese Lektion in zwei etwa gleich große Abschnitte: Testen und Beweisen. Von Testen haben Sie wahrscheinlich schon mehr gehört, landläufig wird Qualitäts\-sicherung und Testen für Software fast synonym verwendet. Innerhalb der Informatik hat das Beweisen, auch Verifikation genannt, dagegen eine größere Tradition. Bei der Entwicklung von Programmiersprachen stand meist die formale Semantik der Programme und die Möglichkeit ihrer Verifikation im Vordergrund. Von Ihnen verlangt es wieder eine ganz andere Denkweise als in anderen Kapiteln und Abschnitten dieses Moduls, nämlich den Umgang mit mathematischen Formeln und logischen Beziehungen.

Dieses letzte Vorwort des Moduls nutzen wir als Gelegenheit für persönliche Worte zum Abschluss. Bei der Zusammenstellung der Inhalte wurde uns wieder deutlich, dass Softwareengineering längst das Format eines kleinen und überschaubaren Katalogs von Rezepten für die Softwareerstellung überstiegen hat. Die Verflechtungen zu anderen Informatikbereichen sind immer mehr gewachsen, und insbesondere auch die Vielfalt der wissenschaftlichen Methoden, die in den unterschiedlichen Bereichen von Softwareengineering zur Anwendung kommen. Sie haben dies sicherlich auch am Stil unserer Texte gemerkt. Nicht nur unterscheidet dieser sich hier und da, weil zwei Autoren stets auch zwei Stile mitbringen, sondern weil zum Beispiel die historische Sicht auf die Entwicklung des Softwareengineering, die ingenieurmäßige Sicht auf die Konstruktion von Softwaresystemen aus teilweise wiederverwendbaren Komponenten und die mathematisch-logische Sicht auf Beweise von Eigenschaften der Artefakte des Softwareengineering (Modelle und Programme) völlig unterschiedliche Denkweisen erfordern. Wir hoffen, dass diese Breite Sie nicht zu sehr verwirrt hat, sondern dass die Vielfalt der Sichten auf dieselbe Sache Sie -- wie uns -- fasziniert und inspiriert, denn eigentlich ergeben all diese Denkweisen erst in ihrem Zusammenspiel einen Sinn.

Wir wünschen Ihnen Erfolg und Spaß beim Lernen, bei der Klausur, und vielleicht auch beim Einsatz der erworbenen Kompetenzen.

Jörg Desel und Maren Stephan  

\newpage

\sttpUniversalkasten{Lernziele zu Lektion 7}{Nach dieser Lektion
	\begin{itemize}
		\item können Sie bewerten, welche Qualitätssicherungsmaßnahmen (Testverfahren, Verifikation) für Softwareprodukte anwendbar sind und in welchem Maße sie geeignet sind, Fehlfunktionen aufzudecken,
		\item beherrschen Sie die Prinzipien von Black-Box-Test und White-Box-Test und können sie exemplarisch auf Programme anwenden,
		\item kennen Sie den Unterschied zwischen Verifikation und Model Checking,
		\item können Sie die partielle Korrektheit kleinerer imperativer Programme mit Hilfe des Hoare-Kalküls beweisen,
		\item können Sie die Terminierung von Schleifen und von rekursiven Funktionsaufrufen mit Hilfe von Abstiegsfunktionen beweisen.
	\end{itemize}
}

